#!/usr/bin/env python3
# This Python file uses the following encoding: utf-8

import os
import sys
import shutil
import platform
import subprocess
from distutils.core import setup, Command, Extension
from distutils.version import LooseVersion
from distutils.command.build import build
# from efl2 import __version__, __version_info__ as vers


script_path = os.path.dirname(os.path.abspath(__file__))

# python-efl version (change in efl/__init__.py)
# RELEASE = __version__
RELEASE = "2.0.0-test1"
# VERSION = "%d.%d" % (vers[0], vers[1] if vers[2] < 99 else vers[1] + 1)

# dependencies
# EFL_MIN_VER = RELEASE
EFL_MIN_VER = "1.23.0"


# === Check for python ===
sys.stdout.write("Checking for Python: ")
py_ver = sys.version_info
py_ver = "%s.%s.%s" % (py_ver[0], py_ver[1], py_ver[2])
if sys.hexversion < 0x030400f0:
    raise SystemExit("too old. Found: %s  Need at least 3.4.0" % py_ver)
else:
    sys.stdout.write("OK, found %s\n" % py_ver)


# === pkg-config ===
def pkg_config(name, require, min_vers=None):
    try:
        sys.stdout.write("Checking for " + name + ": ")

        call = subprocess.Popen(["pkg-config", "--modversion", require],
                                stdout=subprocess.PIPE)
        out, err = call.communicate()
        if call.returncode != 0:
            raise SystemExit("Did not find " + name + " with 'pkg-config'.")

        ver = out.decode("utf-8").strip()
        if min_vers is not None:
            assert (LooseVersion(ver) >= LooseVersion(min_vers)) is True

        call = subprocess.Popen(["pkg-config", "--cflags", require],
                                stdout=subprocess.PIPE)
        out, err = call.communicate()
        cflags = out.decode("utf-8").split()

        call = subprocess.Popen(["pkg-config", "--libs", require],
                                stdout=subprocess.PIPE)
        out, err = call.communicate()
        libs = out.decode("utf-8").split()

        sys.stdout.write("OK, found " + ver + "\n")

        cflags = list(set(cflags))

        return cflags, libs
    except (OSError, subprocess.CalledProcessError):
        raise SystemExit("Did not find " + name + " with 'pkg-config'.")
    except AssertionError:
        raise SystemExit("%s version mismatch. Found: %s  Needed %s" % (
                         name, ver, min_vers))


# === Run all tests (setup.py test) ===
class Test(Command):
    description = 'Run all the available unit tests using efl in build/'
    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        import unittest

        sys.path.insert(0, "build/lib.%s-%s-%d.%d" % (
                            platform.system().lower(), platform.machine(),
                            sys.version_info[0], sys.version_info[1]))
        if "efl2" in sys.modules:
            del sys.modules["efl2"]

        loader = unittest.TestLoader()
        suite = loader.discover('./tests')
        runner = unittest.TextTestRunner(verbosity=1, buffer=True)
        runner.run(suite)


# === Aggressive clean command (setup.py clean) ===
class CleanALL(Command):
    description = 'Aggressive clean command, try to remove EVERYTHING'
    user_options = []

    MAGIC = 'PYOLIAN AUTOGENERATED FILE (never change this line)'

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        # clean *.pyc and __pycache__ in the while tree
        for root, dirs, files in os.walk(script_path, topdown=False):
            for f in files:
                full_path = os.path.join(root, f)
                if f.endswith('.pyc') or self.is_generated(full_path):
                    self.remove_f(full_path)
            for d in dirs:
                full_path = os.path.join(root, d)
                if not os.listdir(full_path):  # empty dir ?
                    self.remove_d(full_path)
                elif d == '__pycache__':
                    self.remove_t(full_path)

        # clean root folder
        self.remove_t(os.path.join(script_path, 'build'))
        self.remove_t(os.path.join(script_path, 'dist'))

    def is_generated(self, full_path):
        if not full_path.endswith(('.h', '.c', '.py')):
            return False
        with open(full_path, 'r') as f:
            for i in range(3):
                line = f.readline()
                if line and self.MAGIC in line:
                    return True
        return False

    @staticmethod
    def remove_f(full_path):
        print('removing file: %s' % os.path.relpath(full_path))
        os.remove(full_path)

    @staticmethod
    def remove_d(full_path):
        print("removing empty dir: %s/" % os.path.relpath(full_path))
        os.rmdir(full_path)

    @staticmethod
    def remove_t(full_path):
        if os.path.isdir(full_path):
            print("pruning dir: %s/" % os.path.relpath(full_path))
            shutil.rmtree(full_path)


# === pyolian generator (setup.py generate) ===
class Generate(Command):
    description = 'Pyolian generator'
    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        print('generating bindings source code using pyolian')

        # Use pyolian from efl tree (temporary hack, until merged in efl tree)
        pyolian_path = os.path.join('/', 'home', 'dave', 'e', 'core', 'efl', 'src', 'scripts')
        sys.path.insert(0, pyolian_path)
        from pyolian.generator import Template

        # # #  T E S T  # # #
        test_tmpl = Template('templates/TESTING.template')
        test_tmpl.render('TESTING.OUT', cls='Efl.Loop', ns='Efl.Ui')
        # # #  T E S T  # # #

        extra_context = {
            'excludes': [
                # Efl.Loop
                'efl_loop_job',                         # futures
                'efl_loop_timeout',                     # futures
                'efl_loop_app_efl_version_get',         # Efl.Version (struct)
                'efl_loop_efl_version_get',             # Efl.Version (struct)
                # Efl.Config        
                'efl_config_set',                       # Eina_Value *
                'efl_config_get',                       # Eina_Value *
                'efl_config_list_get',                  # Eina_Iterator *
                # Efl.Part      
                'efl_part',                             # special lifetime ??
                # Efl.Config.Global     
                'efl_config_profile_iterate',           # Eina_Iterator
                # Efl.Gfx       
                'efl_gfx_color_part_get',               # keyed property
                'efl_gfx_color_part_set',               # keyed property
                # Efl.Gfx.Path      
                'efl_gfx_path_bounds_get',              # Eina.Rectangle
                # Efl.Gfx.Buffer
                'efl_gfx_buffer_map',                   # Eina.Rw_Slice
                'efl_gfx_buffer_unmap',                 # Eina.Rw_Slice
                'efl_gfx_buffer_copy_set',              # Eina.Slice
                'efl_gfx_buffer_managed_set',           # Eina.Slice
                'efl_gfx_buffer_managed_get',           # Eina.Slice
                # Efl.Gfx.Map       
                'efl_gfx_map_point_coord_get',          # keyed property
                'efl_gfx_map_point_image_uv_get',       # keyed property
                'efl_gfx_map_color_get',                # keyed property
                'efl_gfx_map_color_set',                # keyed property
                'efl_gfx_map_point_z_get',              # keyed property
                'efl_gfx_map_point_coord_set',          # keyed property
                'efl_gfx_map_point_image_uv_set',       # keyed property
            ]
        }

        # Warm-up the templates
        clsc_tmpl = Template('templates/class.c.template', context=extra_context)
        clsh_tmpl = Template('templates/class.h.template', context=extra_context)
        strc_tmpl = Template('templates/struct.c.template', context=extra_context)
        strh_tmpl = Template('templates/struct.h.template', context=extra_context)
        init_tmpl = Template('templates/module.__init__.py.template', context=extra_context)
        modc_tmpl = Template('templates/module.c.template', context=extra_context)

        # Efl
        clsc_tmpl.render('efl2/efl.app.c', cls='Efl.App')  # AbstractClass
        clsh_tmpl.render('efl2/efl.app.h', cls='Efl.App')

        clsc_tmpl.render('efl2/efl.loop.c', cls='Efl.Loop')  # AbstractClass
        clsh_tmpl.render('efl2/efl.loop.h', cls='Efl.Loop')

        clsc_tmpl.render('efl2/efl.loop_user.c', cls='Efl.Loop_Consumer')  # AbstractClass
        clsh_tmpl.render('efl2/efl.loop_user.h', cls='Efl.Loop_Consumer')

        clsc_tmpl.render('efl2/efl.loop_timer.c', cls='Efl.Loop_Timer')  # Class
        clsh_tmpl.render('efl2/efl.loop_timer.h', cls='Efl.Loop_Timer')

        clsc_tmpl.render('efl2/efl.loop_fd.c', cls='Efl.Loop_Fd')  # Class
        clsh_tmpl.render('efl2/efl.loop_fd.h', cls='Efl.Loop_Fd')

        # Efl.Gfx
        init_tmpl.render('efl2/gfx/__init__.py', ns='Efl.Gfx')  # Namespace
        modc_tmpl.render('efl2/gfx/_gfx.module.c', ns='Efl.Gfx')

        clsc_tmpl.render('efl2/gfx/efl.gfx.color.c', cls='Efl.Gfx.Color')  # Mixin
        clsh_tmpl.render('efl2/gfx/efl.gfx.color.h', cls='Efl.Gfx.Color')

        clsc_tmpl.render('efl2/gfx/efl.gfx.mapping.c', cls='Efl.Gfx.Mapping')  # Mixin
        clsh_tmpl.render('efl2/gfx/efl.gfx.mapping.h', cls='Efl.Gfx.Mapping')

        clsc_tmpl.render('efl2/gfx/efl.gfx.hint.c', cls='Efl.Gfx.Hint')  # Iface
        clsh_tmpl.render('efl2/gfx/efl.gfx.hint.h', cls='Efl.Gfx.Hint')

        clsc_tmpl.render('efl2/gfx/efl.gfx.image.c', cls='Efl.Gfx.Image')  # Iface
        clsh_tmpl.render('efl2/gfx/efl.gfx.image.h', cls='Efl.Gfx.Image')

        clsc_tmpl.render('efl2/gfx/efl.stack.c', cls='Efl.Gfx.Stack')  # Iface
        clsh_tmpl.render('efl2/gfx/efl.stack.h', cls='Efl.Gfx.Stack')

        strc_tmpl.render('efl2/gfx/efl.gfx.dash.c', struct='Efl.Gfx.Dash')  # Struct
        strh_tmpl.render('efl2/gfx/efl.gfx.dash.h', struct='Efl.Gfx.Dash')

        # TODO sub-sub-module
        # clsc_tmpl.render('efl2/gfx/size/efl.gfx.size.hint.c', cls='Efl.Gfx.Size.Hint')
        # clsh_tmpl.render('efl2/gfx/size/efl.gfx.size.hint.h', cls='Efl.Gfx.Size.Hint')


# === augmented build command ===
class Build(build):
    def run(self):
        self.run_command("generate")
        build.run(self)


eflcflags, efllibs = pkg_config('EFL', 'efl', EFL_MIN_VER)

ext_modules = []
packages = [
    'efl2',
    'efl2.gfx',
]


def efl_module(name, sources):
    mod = Extension(name,
                    define_macros=[
                        ('EFL_BETA_API_SUPPORT', 1),
                        ('EFL_EO_API_SUPPORT', 1),
                        # ('EFL_NOLEGACY_API_SUPPORT', 1),
                    ],
                    # include_dirs = ['/usr/local/include'],
                    # libraries = ['tcl83'],
                    # library_dirs = ['/usr/local/lib'],
                    # extra_compile_args = cflags + common_cflags,
                    # extra_link_args = libs + eina_libs
                    extra_compile_args=eflcflags,
                    extra_link_args=efllibs,
                    sources=sources)
    ext_modules.append(mod)


# efl namespace module
efl_module('efl2._efl', [
    'efl2/eo_utils.c',
    'efl2/_efl.module.c',
    'efl2/efl.object.c',
    'efl2/efl.loop.c',
    'efl2/efl.loop_consumer.c',
    'efl2/efl.gfx.c',
])

# efl.gfx namespace module (not complete)
efl_module('efl2.gfx._gfx', [
    'efl2/gfx/_gfx.module.c',
    'efl2/gfx/efl.gfx.stack.c',
    'efl2/gfx/efl.gfx.mapping.c',
    'efl2/gfx/efl.gfx.hint.c',
    'efl2/gfx/efl.gfx.image.c',
    'efl2/gfx/efl.gfx.dash.c',  # struct
])


setup(
    name="python-efl2",
    version='0.0.0',
    description='This is a demo package',
    author='davemds',
    author_email='dave@gurumeditation.it',
    url='https://www.enlightenment.org',
    long_description=''' This is really just a demo package.''',
    packages=packages,
    # ext_package = "efl2",
    ext_modules=ext_modules,
    cmdclass={
        'clean': CleanALL,
        'generate': Generate,
        'build': Build,
        'test': Test, 'tests': Test,
    },
)
